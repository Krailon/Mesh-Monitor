A!	MeshMonitor-1.0.29193	2.0	C#

X	c:01/000	com.ibm.saguaro.system.Assembly
X	c:01/001	com.ibm.saguaro.system.Util
X	c:01/002	com.ibm.saguaro.system.Timer
X	c:01/003	com.ibm.saguaro.system.Time
X	c:01/004	com.ibm.saguaro.system.MoteException
X	c:01/005	com.ibm.saguaro.system.Device
X	c:01/006	com.ibm.saguaro.system.SDev
X	c:01/007	com.ibm.saguaro.system.CDev
X	c:01/008	com.ibm.saguaro.system.OutOfResourcesException
X	c:01/009	com.ibm.saguaro.system.OsException
X	c:01/00A	com.ibm.saguaro.system.NullReferenceException
X	c:01/00B	com.ibm.saguaro.system.SystemException
X	c:01/00C	com.ibm.saguaro.system.Mote
X	c:01/00D	com.ibm.saguaro.system.LIP
X	c:01/00E	com.ibm.saguaro.system.LED
X	c:01/00F	com.ibm.saguaro.system.InvalidCastException
X	c:01/010	com.ibm.saguaro.system.IndexOutOfRangeException
X	c:01/011	com.ibm.saguaro.system.I2C
X	c:01/012	com.ibm.saguaro.system.GPIO
X	c:01/013	com.ibm.saguaro.system.Err
X	c:01/014	com.ibm.saguaro.system.DeviceException
X	c:01/015	com.ibm.saguaro.system.SPI
X	c:01/016	com.ibm.saguaro.system.Radio
X	c:01/017	com.ibm.saguaro.system.WLIP
X	c:01/018	com.ibm.saguaro.system.ArrayTypeMismatchException
X	c:01/019	com.ibm.saguaro.system.ArithmException
X	c:01/01A	com.ibm.saguaro.system.ArgumentException
X	c:01/01B	com.ibm.saguaro.system.AccessException
X	c:01/01C	com.ibm.saguaro.system.ADC
X	c:02/000	com.ibm.iris.IRIS

C!	c:003	TRU.MeshMonitor.MeshMonitor	-1	0	c:000
R	Reply	b[]	0	0
R	ADC_Device	r:com.ibm.saguaro.system.ADC	0	1
R	GPIO_Device	r:com.ibm.saguaro.system.GPIO	0	2
G	ADC_CHANNEL_MASK	u	0	2
G	GREEN_LED	b	0	1
G	LIGHT_PWR_PIN	b	0	37
G	READ_INTERVAL	u	0	5
G	RED_LED	b	0	2
G	REPLY_SIZE	u	0	64
G	TEMP_PWR_PIN	b	0	16
G	YELLOW_LED	b	0	0
M	ADCReadCallback(u,b[],u,u,l)i	-1	m:004F	0009E	130
M!	MeshMonitor(r:TRU.MeshMonitor.MeshMonitor)v	-1	m:0090	00120	6
M	onData(u,b[],u)i	-1	m:0093	00126	18

C	c:005	com.ibm.saguaro.system.$tatics	-1	-1	c:01/000
r	TRU.MeshMonitor.MeshMonitor.Reply	b[]	-1	0
r	TRU.MeshMonitor.MeshMonitor.ADC_Device	r:com.ibm.saguaro.system.ADC	-1	1
r	TRU.MeshMonitor.MeshMonitor.GPIO_Device	r:com.ibm.saguaro.system.GPIO	-1	2
M	__init()v	-1	m:000E	0001C	130

c	00029	0	17	0	17	0	m:000E
c	00033	0	18	0	18	0	m:000E
c	0003D	0	19	0	19	0	m:000E
c	00043	0	21	0	21	0	m:000E
c	00044	0	22	0	22	0	m:000E
c	0004A	0	24	0	24	0	m:000E
c	00052	0	25	0	25	0	m:000E
c	00059	0	26	0	26	0	m:000E
c	00064	0	27	0	27	0	m:000E
c	00071	0	28	0	28	0	m:000E
c	0007C	0	29	0	29	0	m:000E
c	0008F	0	31	0	31	0	m:000E
c	00095	0	32	0	32	0	m:000E
c	0009B	0	33	0	33	0	m:000E
e	0009E	m:000E
c	000A1	0	41	0	41	0	m:004F
l	000A1	00120	i	CS$1$0000	m:004F	8
l	000A1	00120	z	CS$4$0001	m:004F	9
l	000A1	00120	b[]	CS$0$0002	m:004F	10
l	000A1	00120	u	offset	m:004F	6
l	000A1	00120	b[]	sensor	m:004F	7
l	000A1	00120	u	Flags	m:004F	0
l	000A1	00120	b[]	Data	m:004F	1
l	000A1	00120	u	Length	m:004F	2
l	000A1	00120	u	Info	m:004F	3
l	000A1	00120	l	Time	m:004F	4
c	000A7	0	44	0	44	0	m:004F
c	000BA	0	45	0	45	0	m:004F
c	000C1	0	46	0	46	0	m:004F
c	000CC	0	47	0	47	0	m:004F
c	000D8	0	50	0	50	0	m:004F
c	000E4	0	51	0	51	0	m:004F
c	000EF	0	52	0	52	0	m:004F
c	000F9	0	55	0	55	0	m:004F
c	00104	0	56	0	56	0	m:004F
c	00111	0	57	0	57	0	m:004F
c	0011A	0	59	0	59	0	m:004F
c	0011D	0	60	0	60	0	m:004F
e	00120	m:004F
l!	00123	00126	r:TRU.MeshMonitor.MeshMonitor	this	m:0090	0
e!	00126	m:0090
c	00129	0	36	0	36	0	m:0093
l	00129	00138	i	CS$1$0000	m:0093	3
l	00129	00138	u	Info	m:0093	0
l	00129	00138	b[]	Buffer	m:0093	1
l	00129	00138	u	Length	m:0093	2
c	00134	0	37	0	37	0	m:0093
c	00136	0	38	0	38	0	m:0093
e	00138	m:0093
S	C:\Users\Kerberos\Dropbox\Programming\Repos\Mesh-Monitor\MoteRunner\MeshMonitor.cs
:	namespace TRU.MeshMonitor {
:		using com.ibm.saguaro.system;
:		using com.ibm.iris;
:		
:		public class MeshMonitor {
:			
:			// Globals
:			private const uint ADC_CHANNEL_MASK = 0x02;
:			private const uint REPLY_SIZE = 0x40; // 64
:			private const uint READ_INTERVAL = 5; // 5s 
:			private const byte TEMP_PWR_PIN = IRIS.PIN_PW0; // PC0
:			private const byte LIGHT_PWR_PIN = IRIS.PIN_INT5; // PE5
:			private const byte YELLOW_LED = 0;
:			private const byte GREEN_LED = 1;
:			private const byte RED_LED = 2;
:			
:			private static byte[] Reply = new byte[REPLY_SIZE];
:			private static ADC ADC_Device = new ADC();
:			private static GPIO GPIO_Device = new GPIO();
:	
:			static MeshMonitor() {
:				LED.setState(YELLOW_LED, 1);
:	
:				Assembly.setDataHandler(onData);
:				GPIO_Device.open();
:				GPIO_Device.configureOutput(TEMP_PWR_PIN, GPIO.OUT_SET);
:				ADC_Device.open(ADC_CHANNEL_MASK, GPIO.NO_PIN, 0, 0); // Manual power; No warmup; No interval (ltr)
:				ADC_Device.setReadHandler(ADCReadCallback);
:				ADC_Device.read(Device.TIMED, 1, Time.currentTicks() + Time.toTickSpan(Time.SECONDS, READ_INTERVAL));
:	
:				LED.setState(YELLOW_LED, 0); 
:				LED.setState(GREEN_LED, 1);
:			}
:	
:			private static int onData(uint Info, byte[] Buffer, uint Length) {
:				Util.copyData(Buffer, 0, Reply, 0, Length);
:				return 0;
:			}
:	
:			private static int ADCReadCallback(uint Flags, byte[] Data, uint Length, uint Info, long Time) {
:				uint offset = LIP.getPortOff() + 1;
:				byte[] sensor;
:	
:				if (GPIO_Device.doPin(GPIO.CTRL_READ, TEMP_PWR_PIN) == 0) {
:					sensor = new byte[] {0, 0}; // 0 => Temperature
:					GPIO_Device.configureOutput(TEMP_PWR_PIN, GPIO.OUT_SET);
:					GPIO_Device.configureOutput(LIGHT_PWR_PIN, GPIO.OUT_CLR);
:				}
:				else {
:					sensor = new byte[] {1, 0}; // 1 => Light
:					GPIO_Device.configureOutput(LIGHT_PWR_PIN, GPIO.OUT_SET);
:					GPIO_Device.configureOutput(TEMP_PWR_PIN, GPIO.OUT_CLR);
:				}
:	
:				Util.copyData(sensor, 0, Reply, offset, 2);			
:				Util.copyData(Data, 0, Reply, offset + 2, 2);
:				LIP.send(Reply, 0, REPLY_SIZE);
:	
:				return 0;
:			}
:	
:		}
:	
:	}
